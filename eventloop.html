<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <pre>JAVASCRIPT EVENT LOOP – CLEAN SUMMARY (PLAIN TEXT)

CALL STACK

JavaScript is single-threaded, and it executes code inside the Call Stack.

Functions run one at a time (LIFO: Last In, First Out).

The Call Stack never waits for timers or network responses. Those are handled by the browser.

Example:
console.log("A");
console.log("B");
Both run immediately.

WEB APIS

These are features provided by the browser, not by JavaScript itself.
Examples: setTimeout, setInterval, DOM events, fetch, Promises (internally), MutationObserver.

When you call something like setTimeout, the browser handles the timing. When it finishes, it sends the callback into a queue.

Example:
setTimeout(() => console.log("Timeout"), 2000);

The browser sets a 2-second timer. When the timer ends, the callback is put into the Task Queue, not run immediately.

TASK QUEUE (MACROTASK QUEUE)

Stores callbacks from setTimeout, setInterval, DOM events, message events.

FIFO (First in, first out).

Tasks in this queue are executed ONLY when:
a) Call Stack is empty
b) Microtask Queue is empty

MICROTASK QUEUE

Stores high-priority callbacks:

Promise .then / .catch / .finally

queueMicrotask()

MutationObserver

Microtasks run BEFORE any task in the Task Queue, even if the task has 0ms delay.

Example:
setTimeout(() => console.log("timeout"), 0);
Promise.resolve().then(() => console.log("promise"));

Output:
promise
timeout

EVENT LOOP

The event loop is NOT a variable or an object. It is an internal algorithm inside the browser/Node.js runtime.

Its job:

Check if Call Stack is empty.

If empty → run ALL microtasks in the Microtask Queue.

After microtasks are done → take ONE task from the Task Queue.

Possibly allow the browser to render.

Repeat forever.

It is like a traffic controller coordinating different queues.

FULL EXECUTION EXAMPLE (WITH ORDER)

Code:
console.log("Start");

setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("End");

Execution:

Start printed immediately

Timeout callback goes to Task Queue

Promise callback goes to Microtask Queue

End printed

Event Loop runs Microtasks → prints "Promise"

Event Loop runs Task Queue → prints "Timeout"

Final Output:
Start
End
Promise
Timeout

MICROTASK STARVATION

Concept:

Because Microtasks have higher priority, the Event Loop must empty the Microtask Queue completely before running any Task Queue item.

If microtasks keep adding MORE microtasks endlessly, tasks will NEVER run.

This is called Microtask Starvation (or starvation of the Task Queue).

It means:

setTimeout callbacks may never run

the UI may freeze

rendering may be blocked

Example of microtask starvation:

function repeatForever() {
Promise.resolve().then(() => {
console.log("Microtask running...");
repeatForever(); // adds another microtask
});
}

repeatForever();

setTimeout(() => {
console.log("You will never see this.");
}, 0);

What happens:

repeatForever schedules a microtask

When the microtask runs, it adds another microtask

This creates an infinite chain of microtasks

The Event Loop keeps draining microtasks forever

The task queue (setTimeout) is never reached

Output:
Microtask running...
Microtask running...
Microtask running...
(forever)

The setTimeout callback is never printed → starvation.

Explanation:

Microtasks always run BEFORE Task Queue items. If new microtasks keep appearing, the Task Queue is starved indefinitely.

KEY TAKEAWAYS

Call Stack executes synchronous code.

Web APIs handle async operations.

Task Queue handles timer callbacks and events.

Microtask Queue handles promises and runs before Task Queue.

Event Loop coordinates everything.

Microtasks can cause starvation if they generate more microtasks infinitely.</pre>
</body>
</html>